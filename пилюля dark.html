<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Animated Mood Capsule — demo</title>
<style>
  body{margin:0; background:#0a0d12; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; padding:24px;}
  .pill-wrap{
    width: min(100%, 560px);
    aspect-ratio: 4/3;
    margin: 0 auto;
    border-radius: 18px;
    background:
      radial-gradient(80% 60% at 40% 35%, rgba(60,80,120,.25), rgba(10,12,18,0) 60%),
      #0a0d12;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 16px 40px rgba(0,0,0,.35);
    position: relative; overflow: hidden;
  }
  #pillCanvas{ width:100%; height:100%; display:block; }

  .pill-control{
    position:absolute; left:16px; right:16px; bottom:14px;
    display:flex; gap:12px; align-items:center;
    background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08);
    padding:10px 12px; border-radius:12px; backdrop-filter: blur(6px);
    color:#cfe6ff;
  }
  .pill-control input[type="range"]{ width:100%; }
  .pill-control span{ opacity:.85; font-size:12px; white-space:nowrap; }
</style>
</head>
<body>
  <div class="pill-wrap">
    <canvas id="pillCanvas"></canvas>
    <!-- демо-ползунок (для проверки работы). Можно удалить, если не нужен -->
    <div class="pill-control">
      <input id="pillMoodLocal" type="range" min="0" max="100" value="50" />
      <span id="pillMoodLabel">Нейтрально</span>
    </div>
  </div>

  <!-- Скрипт анимации -->
  <script>
  (() => {
    const canvas = document.getElementById('pillCanvas');
    const ctx = canvas.getContext('2d');

    const rotationPeriod = 10;   // сек/оборот
    const breathAmp = 0.04;      // ±4%
    const breathPeriod = 1.6;    // сек на дыхание
    const morphAmpBase = 0.06;   // базовая амплитуда морфинга
    const morphSpeed = 0.7;      // рад/с

    // Управление извне: 0..1
    let mood01 = 0.5, moodVis = 0.5;
    window.setPillMood01 = (x)=>{ mood01 = Math.max(0, Math.min(1, x)); };

    // демо-ползунок
    const demo = document.getElementById('pillMoodLocal');
    const demoLbl = document.getElementById('pillMoodLabel');
    if (demo) {
      const labels = ['Очень плохо','Плохо','Нейтрально','Хорошо','Отлично'];
      demo.addEventListener('input', e=>{
        const v = e.target.value/100;
        window.setPillMood01(v);
        demoLbl.textContent = labels[Math.round(v*4)];
      });
    }

    function fit(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = Math.round(w*dpr); canvas.height = Math.round(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', fit); fit();

    function pathCapsule(c, W, H, R){
      const r = Math.max(0, Math.min(R, Math.min(W,H)/2));
      const x = -W/2, y = -H/2;
      c.beginPath();
      c.moveTo(x + r, y);
      c.lineTo(x + W - r, y);
      c.quadraticCurveTo(x + W, y, x + W, y + r);
      c.lineTo(x + W, y + H - r);
      c.quadraticCurveTo(x + W, y + H, x + W - r, y + H);
      c.lineTo(x + r, y + H);
      c.quadraticCurveTo(x, y + H, x, y + H - r);
      c.lineTo(x, y + r);
      c.quadraticCurveTo(x, y, x + r, y);
      c.closePath();
    }

    function lerp(a,b,t){ return a + (b-a)*t; }
    function hexToRgb(h){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
      return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:255,g:255,b:255}; }
    function mixHex(h1,h2,t,alpha=1){
      const A=hexToRgb(h1), B=hexToRgb(h2);
      const r=Math.round(lerp(A.r,B.r,t)), g=Math.round(lerp(A.g,B.g,t)), b=Math.round(lerp(A.b,B.b,t));
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function palette(m){
      const warm1='#ff5e57', warm2='#ffb36b';
      const mid1 ='#19d06a', mid2 ='#66e08f';
      const cool1='#00d2ff', cool2='#38f9d7';
      let cA,cB;
      if(m<0.5){ const t=m/0.5; cA=mixHex(warm1,mid1,t); cB=mixHex(warm2,mid2,t); }
      else { const t=(m-0.5)/0.5; cA=mixHex(mid1,cool1,t); cB=mixHex(mid2,cool2,t); }
      return {
        baseDark: mixHex('#0b1220', '#081019', m, 1),
        baseMid:  mixHex('#101a2f', '#0f2134', m, 1),
        irA: cA, irB: cB,
        rimA: mixHex('#ff8a3d', '#00ffee', m, .42),
        rimB: mixHex('#ffd080', '#a0d8ff', m, .18),
        glintA: mixHex('#ffe5d4', '#e8fbff', m, .9),
        glintB: mixHex('#ffd0f0', '#c7e6ff', m, .78)
      };
    }

    // микрошум для «матовой» реалистичности
    const noise = document.createElement('canvas'); const nctx = noise.getContext('2d');
    noise.width = noise.height = 256; const img = nctx.createImageData(256,256);
    for (let i=0; i<img.data.length; i+=4){
      const v = 230 + (Math.random()*25)|0;
      img.data[i]=img.data[i+1]=img.data[i+2]=v; img.data[i+3]=10;
    } nctx.putImageData(img,0,0);

    function glossyBand(x1,y1,x2,y2, a1, a2, alpha){
      const g = ctx.createLinearGradient(x1,y1,x2,y2);
      g.addColorStop(0, 'rgba(255,255,255,0)');
      g.addColorStop(0.35, a1);
      g.addColorStop(0.65, a2);
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = alpha;
      ctx.fillStyle = g;
      ctx.fillRect(-9999,-9999,19999,19999);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }
    function glint(cx,cy, rx,ry, color='rgba(255,255,255,.9)', a=1){
      const gr = ctx.createRadialGradient(cx,cy,0, cx,cy, Math.max(rx,ry));
      gr.addColorStop(0, color); gr.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.globalCompositeOperation = 'screen'; ctx.globalAlpha = a;
      ctx.fillStyle = gr; ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
    }

    let start = performance.now();
    function frame(nowMs){
      const t = (nowMs - start)/1000;
      moodVis += (mood01 - moodVis) * 0.08;

      const W0 = canvas.clientWidth, H0 = canvas.clientHeight;
      ctx.clearRect(0,0,W0,H0);

      const cx=W0/2, cy=H0/2;
      const rot = (2*Math.PI/rotationPeriod)*t;
      const breath = 1 + breathAmp*Math.sin(2*Math.PI*t/breathPeriod);
      const morphAmp = morphAmpBase * (0.7 + 0.6*Math.abs(moodVis-0.5));
      const morph = Math.sin(t*morphSpeed);

      const baseW = W0*0.58, baseH = H0*0.32;
      const W = baseW * (1 + morphAmp*0.55*morph) * (1 - 0.05*(moodVis-0.5));
      const H = baseH * (1 - morphAmp*0.35*morph) * (1 + 0.05*(moodVis-0.5));
      const R = Math.min(W,H)/2 * (0.86 + 0.10*Math.sin(t*morphSpeed*1.7));
      const pal = palette(moodVis);

      // Тень
      ctx.save();
      ctx.translate(cx, cy + H*0.26);
      ctx.rotate(rot + 0.5);
      const shGrad = ctx.createRadialGradient(0,0,H*0.05, 0,0, W*0.8);
      shGrad.addColorStop(0, 'rgba(0,0,0,.42)');
      shGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = shGrad;
      ctx.beginPath(); ctx.ellipse(0,0, W*0.64, H*0.36, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // Капсула
      ctx.save();
      ctx.translate(cx, cy); ctx.rotate(rot + 0.5); ctx.scale(breath, breath);
      pathCapsule(ctx, W, H, R); ctx.save(); ctx.clip();

      // База
      const base = ctx.createLinearGradient(-W/2,-H/2, W/2,H/2);
      base.addColorStop(0.0, pal.baseDark);
      base.addColorStop(0.45, pal.baseMid);
      base.addColorStop(1.0, '#070b14');
      ctx.fillStyle = base; ctx.fillRect(-W, -H, W*2, H*2);

      // Радужные полосы
      glossyBand(-W*0.9,-H*0.2,  W*0.7,H*0.15, pal.irA, pal.irB, .95);
      glossyBand(-W*0.25,-H*0.9, W*0.25,H*0.8,  mixHex('#ffd070','#a0d8ff',moodVis,.30), mixHex('#90e0ff','#70ffd8',moodVis,.32), .9);
      glossyBand(-W*0.7,H*0.28,  W*0.85,-H*0.38, mixHex('#ff6090','#60ffd0',moodVis,.28), mixHex('#60ffd0','#50a0ff',moodVis,.30), .85);

      // Блики
      glint(W*0.30, -H*0.28, W*0.22, H*0.20, pal.glintA, .95);
      glint(-W*0.34, H*0.26, W*0.18, H*0.16, pal.glintB, .8);

      // Внутренняя ось
      const core = ctx.createLinearGradient(-W/2,0, W/2,0);
      core.addColorStop(0.0, 'rgba(0,0,0,0.16)');
      core.addColorStop(0.5, 'rgba(255,255,255,0.06)');
      core.addColorStop(1.0, 'rgba(0,0,0,0.16)');
      ctx.globalCompositeOperation = 'overlay';
      ctx.fillStyle = core; ctx.fillRect(-W, -H, W*2, H*2);
      ctx.globalCompositeOperation = 'source-over';

      // Краевая каёмка
      const rim = ctx.createLinearGradient(-W/2,-H/2, W/2,H/2);
      rim.addColorStop(0, pal.rimA); rim.addColorStop(0.5, pal.rimB); rim.addColorStop(1, pal.rimA);
      ctx.lineWidth = Math.max(1.5, Math.min(W,H)/18);
      ctx.strokeStyle = rim; ctx.shadowColor = 'rgba(120,180,255,.45)'; ctx.shadowBlur = 12;
      pathCapsule(ctx, W, H, R);
      ctx.globalCompositeOperation = 'screen'; ctx.stroke();
      ctx.globalCompositeOperation = 'source-over'; ctx.shadowBlur = 0;

      // Тонкая внутренняя кайма
      ctx.lineWidth = 1.2; ctx.strokeStyle = 'rgba(255,255,255,.32)';
      pathCapsule(ctx, W*0.985, H*0.985, R*0.985); ctx.stroke();

      // Разделительное кольцо
      const rx = W*0.015, ry = H*0.44;
      const ringGrad = ctx.createLinearGradient(-rx,0, rx,0);
      ringGrad.addColorStop(0, mixHex('#ff90c0','#60f0ff',moodVis,.95));
      ringGrad.addColorStop(0.5, mixHex('#a0d0ff','#c0fff0',moodVis,.95));
      ringGrad.addColorStop(1, mixHex('#ffd090','#90e0ff',moodVis,.95));
      ctx.lineWidth = Math.max(2.0, Math.min(W,H)/45);
      ctx.strokeStyle = ringGrad; ctx.shadowColor = 'rgba(120,180,255,.45)'; ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.ellipse(0,0, rx, ry, 0, 0, Math.PI*2); ctx.stroke();
      ctx.shadowBlur = 0;

      // Микрошероховатость
      ctx.globalCompositeOperation = 'multiply'; ctx.globalAlpha = 0.06;
      for (let i=0;i<3;i++){ ctx.drawImage(noise, -W + i*128, -H + i*64, W*2, H*2); }
      ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';

      ctx.restore(); // clip
      ctx.restore(); // transform

      // Отражение
      ctx.save();
      ctx.translate(cx, cy + H*0.36);
      ctx.rotate(rot + 0.5); ctx.scale(1, -0.6);
      pathCapsule(ctx, W*0.98, H*0.98, R*0.98); ctx.clip();
      const refl = ctx.createLinearGradient(0,-H,0,H);
      refl.addColorStop(0, 'rgba(255,255,255,.18)'); refl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = refl; ctx.filter = 'blur(3px)';
      ctx.fillRect(-W, -H, W*2, H*2); ctx.filter = 'none';
      ctx.restore();

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>

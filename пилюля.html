<!-- ==== Animated Pill / Capsule ==== -->
<div class="pill-wrap">
  <canvas id="pillCanvas"></canvas>
</div>

<style>
  .pill-wrap{
    width: 100%;
    max-width: 560px;   /* можно убрать, если надо во всю ширину */
    aspect-ratio: 4 / 3;
    margin: 0 auto;
    border-radius: 18px;
    background: radial-gradient(120% 120% at 50% 40%,
      rgba(80,180,110,.25), rgba(20,40,32,.45) 60%, rgba(8,12,16,.75));
    box-shadow: inset 0 1px 0 rgba(255,255,255,.05),
                0 16px 40px rgba(0,0,0,.35);
    overflow: hidden;
  }
  #pillCanvas{ width:100%; height:100%; display:block; }
</style>

<script>
(() => {
  const canvas = document.getElementById('pillCanvas');
  const ctx = canvas.getContext('2d');

  // ------ Параметры анимации (можно трогать) ------
  const rotationPeriod = 10;     // секунд на оборот (8–12с)
  const breathAmp = 0.04;        // ±4% масштаб «дыхания»
  const breathPeriod = 1.6;      // сек на цикл дыхания (1.2–2с)
  const morphAmp = 0.08;         // амплитуда морфинга формы (соотношение сторон)
  const morphSpeed = 0.6;        // скорость морфинга (рад/с)
  const layers = 6;              // количество «стеклянных» слоёв

  // Палитра (зелёные как в примере; можно поменять под тему)
  const colors = {
    core:   '#19d06a',
    mid:    '#66e08f',
    edge:   '#b6f0c9',
    stroke: 'rgba(255,255,255,0.6)'
  };

  // ------ Сервис ------
  function fit() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', fit);
  fit();

  // Рисуем «капсулу» (стадион): ширина W, высота H, радиус скругления R
  function pathCapsule(ctx, W, H, R){
    const r = Math.max(0, Math.min(R, Math.min(W,H)/2));
    const x = -W/2, y = -H/2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + W - r, y);
    ctx.quadraticCurveTo(x + W, y, x + W, y + r);
    ctx.lineTo(x + W, y + H - r);
    ctx.quadraticCurveTo(x + W, y + H, x + W - r, y + H);
    ctx.lineTo(x + r, y + H);
    ctx.quadraticCurveTo(x, y + H, x, y + H - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  // Основной рендер
  let start = performance.now();
  function frame(nowMs){
    const t = (nowMs - start) / 1000;

    // Очистка
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // Центр и общий трансформ
    const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
    ctx.save();
    ctx.translate(cx, cy);

    // Вращение
    const rot = (2*Math.PI / rotationPeriod) * t;
    ctx.rotate(rot);

    // Дыхание
    const breath = 1 + breathAmp * Math.sin(2*Math.PI*t / breathPeriod);
    ctx.scale(breath, breath);

    // Морфинг формы: слегка «жуется» соотношение сторон и радиус
    const morph = Math.sin(t * morphSpeed);
    const baseW = canvas.clientWidth * 0.45;
    const baseH = canvas.clientHeight * 0.28;
    const W = baseW * (1 + morphAmp *  0.65 * morph);
    const H = baseH * (1 - morphAmp *  0.45 * morph);
    const R = Math.min(W,H)/2 * (0.82 + 0.12*Math.sin(t* (morphSpeed*1.7)));

    // Слои «стекла»: от внешнего к центру
    for (let i=0; i<layers; i++){
      const k = (layers-1-i)/(layers-1);   // 1..0
      const w = lerp(W*1.35, W*0.55, k);
      const h = lerp(H*1.35, H*0.55, k);
      const r = lerp(R*1.10, R*0.75, k);

      // Слегка волнистая «выпуклость» (добавка к морфингу)
      const wobble = 1 + 0.015*Math.sin(t*1.8 + i*0.9);
      pathCapsule(ctx, w*wobble, h/wobble, r);

      // Градиент заливки по длинной оси капсулы
      const grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
      const c1 = i < layers-2 ? colors.edge : colors.mid;
      const c2 = i < 2 ? colors.core : colors.mid;
      grad.addColorStop(0, `rgba(255,255,255,${0.06 + 0.04*k})`);
      grad.addColorStop(0.5, c2);
      grad.addColorStop(1, `rgba(0,0,0,${0.12 + 0.08*k})`);

      ctx.fillStyle = grad;
      ctx.globalAlpha = 0.85 - 0.08*i;
      ctx.shadowBlur = 22 - i*3;
      ctx.shadowColor = i<2 ? colors.mid : 'rgba(0,0,0,0)';
      ctx.fill();

      // Тонкий светящийся обвод
      ctx.globalAlpha = 0.55 - 0.08*i;
      ctx.lineWidth = 1.6 + i*0.2;
      ctx.strokeStyle = colors.stroke;
      ctx.shadowBlur = 8 - i*1.1;
      ctx.shadowColor = colors.edge;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    ctx.restore();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
